//
//  Updater.swift
//  
//
//  Created by Brandon Toms on 5/1/22.
//

import Foundation
#if canImport(FoundationNetworking)
import FoundationNetworking
#endif

/// This script fetches the latest [Multicodec table from the Multiformats repository](https://raw.githubusercontent.com/multiformats/multicodec/master/table.csv)
/// attempts to parse the data and generate an Enumeration from it.
///
/// To run this script and fetch the latest Multicodec values simply run the following command at the Multicodec project root
/// ```
/// swift run update-codecs
/// ```
/// This will overwrite the entire Codecs.swift file with the latest codecs.

// MARK: - Multiformat Codec Table Repository URL
var CSVDocumentURL = "https://raw.githubusercontent.com/multiformats/multicodec/master/table.csv"


// MARK: - Templates
let HEADER = """
//
//  Codecs.swift
//
//
//  Created by Brandon Toms on 9/14/20.
//  Updated on {{+date_updated+}}

import Foundation
import VarInt

/// An Enum for navigating supported Multiformat Codecs and their properties, most importantly their Name and Integer Code
///
/// - Warning: Do not use the Codecs `rawValue` directly, instead make sure to use the `code` property to ensure backward compatibility with deprecated codecs.
///
/// This enumeration is autogenerated from the [multicodec table repository](https://raw.githubusercontent.com/multiformats/multicodec/master/table.csv)
///
/// To fetch the latest Multicodecs simply run the following cmd at the Multicodec package root
/// ```
/// swift run update-codecs
/// ```
"""

let ENUM_DEFINITION_TEMPLATE = """
{{+enum_scope+}} enum {{+enum_title+}}{{+enum_rawType+}}{{+enum_protocols+}} {
    {{+enum_cases+}}
    {{+enum_additional_components+}}
    {{+enum_computed_properties+}}
    {{+enum_functions+}}
}
"""

let ENUM_CASE = """
case {{+case_title+}}{{+case_associatedValues+}}{{+case_rawValue+}}
"""

let ENUM_COMPUTED_PROPERTY = """
{{+enum_scope+}} var {{+cp_title+}}:{{+cp_type+}} {
    switch self {
    {{+cp_case+}}
    {{+cp_default+}}
    }
}
"""

let COMPUTED_PROPERTY_CASE = """
case .{{+case_title+}}:
    return {{+case_value+}}
"""

let ENUM_ADDITIONAL_COMPONENTS = """
    //Deprecated Values
    case ipfs

    /// Allows instantiation of a Codec based on it's name
    /// ```
    ///  let p2p = try? Codecs("p2p")
    ///  print(p2p.code)        //"0x01a5"
    ///  print(p2p.name)        //"p2p"
    ///  print(p2p.tag)         //"multihash"
    ///  print(p2p.description) //"libp2p"
    /// ```
    /// - Note: The string name is lowercased and replaces dashes (-) for underscores (_) before checking for a match...
    {{+enum_scope+}} init(_ name:String) throws {
        let n = name.replacingOccurrences(of: "-", with: "_").lowercased()
        //if n == "ipfs" { self = Codecs.p2p; return } //ipfs is deprecated (p2p now) but we support string instantiation...
        guard let match = Codecs.allCases.first(where: { "\\($0)" == n }) else { throw MulticodecError.UnknownCodecString }
        self = match
    }

    /// Instantiation via signed VarInt
    {{+enum_scope+}} init(_ bytes:[UInt8]) throws {
        if let s = Codecs(rawValue: uVarInt(bytes).0) {
            self = s
        } else { throw MulticodecError.UnknownCodecId }
    }
    
    {{+enum_scope+}} init(_ code:Int) throws {
        guard let s = Codecs(rawValue: UInt64(code)) else { throw MulticodecError.UnknownCodecId }
        self = s
    }
    
    {{+enum_scope+}} init(_ code:Int64) throws {
        guard let s = Codecs(rawValue: UInt64(code)) else { throw MulticodecError.UnknownCodecId }
        self = s
    }
    
    {{+enum_scope+}} init(_ code:UInt64) throws {
        guard let s = Codecs(rawValue: code) else { throw MulticodecError.UnknownCodecId }
        self = s
    }

    /// Returns a list of all known Codec names
    {{+enum_scope+}} static var codecNames:[String] { return Codecs.allCases.map { $0.name } }

    /// Returns a list of Codecs that have the specified tag (ex: 'multiaddr' or 'multihash')
    {{+enum_scope+}} static func codecs(withTag _tag:String) -> [Codecs] { return Codecs.allCases.filter( { $0.tag == _tag }) }

    /// Returns a list of all known Codec codes
    {{+enum_scope+}} static var codecCodes:[UInt64] { return Codecs.allCases.map { $0.rawValue } }
    
    /// Returns the code for this Codec
    {{+enum_scope+}} var code:UInt64 {
        // Handle Deprecated Values
        switch self {
        case .ipfs:
            return Codecs.p2p.rawValue
        default:
            return self.rawValue
        }
    }
    
    /// Returns the name for this Codec
    {{+enum_scope+}} var name:String { return "\\(self)".replacingOccurrences(of: "_", with: "-") }
    
    /// Returns the code for this Codec as a VarInt Byte Buffer
    {{+enum_scope+}} var asVarInt:[UInt8] { return putUVarInt(self.rawValue) }
"""

// MARK: - Network Data Fetch
func fetchContents(url:String) -> String? {
    guard let u = URL(string: url) else { print("Invalid URL String"); return nil }
    do {
        let data = try Data(contentsOf: u)
        let str = String(decoding: data, as: UTF8.self)
        //print(str)
        return str
    } catch {
        print("ðŸš« Error Fetching Contents at ðŸš«")
        print("URL: \(u.absoluteString)")
        print("Error: \(error.localizedDescription)")
        print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
    }
    return nil
}

// MARK: - CSV Parsing
struct CSVData {
    let rowNum:Int
    let columns:[(key:String, value:String)]
}

func parseStringIntoCSV(_ csv:String, headerRow:Int? = nil) -> [CSVData] {
    var rows = csv.split(separator: "\n") //TODO: Handle Carriage Returns...
    var headerKeys:[String] = []
    if let hr = headerRow, rows.count > hr {
        headerKeys = rows[hr].split(separator: ",").map { stripLeadingSpaces(String($0)) }
        rows.remove(at: hr)
    }
    return rows.enumerated().compactMap {
        CSVData(rowNum: $0.offset, columns: $0.element.split(separator: ",").enumerated().map {
            if headerKeys.count > $0.offset {
                return (key: headerKeys[$0.offset], value: stripLeadingSpaces(String($0.element)))
            } else {
                return (key: "", value: stripLeadingSpaces(String($0.element)))
            }
        })
    }
}

func stripLeadingSpaces(_ str:String) -> String {
    var s = str; while s.hasPrefix(" ") { s = String(s.dropFirst()) }; return s
}


// MARK: - Enumeration Building Blocks
class EnumCase {
    let title:String
    let rawValue:String?
    let associatedValue:String?
    
    var computedProperties:[String:Any] = [:]
    
    init(title:String, rawValue:String) {
        self.title = title
        self.rawValue = rawValue
        self.associatedValue = nil
    }
    
    init(title:String, associatedValue:String) {
        self.title = title
        self.associatedValue = associatedValue
        self.rawValue = nil
    }
    
    init(title:String) {
        self.title = title
        self.associatedValue = nil
        self.rawValue = nil
    }
}

enum Scope:String {
    case INTERNAL    = "internal"
    case OPEN        = "open"
    case PUBLIC      = "public"
    case PRIVATE     = "private"
    case FILEPRIVATE = "fileprivate"
}

struct ComputedProperty {
    let title:String
    let type:Any
    let defaultValue:String
    let caseKey:String
}

func generateEnum(scope:Scope, title:String, rawType:Any? = nil, protocolConformances:[String], cases:[EnumCase], computedProps:[ComputedProperty] = []) -> Data? {
    let dateFormatter = DateFormatter()
    dateFormatter.dateStyle = .short
    var e = HEADER.replacingOccurrences(of: "{{+date_updated+}}", with: dateFormatter.string(from: Date()))
    
    e = e + "\n" + ENUM_DEFINITION_TEMPLATE
    e = e.replacingOccurrences(of: "{{+enum_scope+}}", with: scope.rawValue)
    e = e.replacingOccurrences(of: "{{+enum_title+}}", with: title) //Enforce CamelCase???
    if let rt = rawType {
        e = e.replacingOccurrences(of: "{{+enum_rawType+}}", with: ":\(rt.self)")
        if !protocolConformances.isEmpty {
            e = e.replacingOccurrences(of: "{{+enum_protocols+}}", with: protocolConformances.map { ", \($0)" }.joined())
        } else { e = e.replacingOccurrences(of: "{{+enum_protocols+}}", with: "") }
    } else {
        e = e.replacingOccurrences(of: "{{+enum_rawType+}}", with: "")
        if !protocolConformances.isEmpty {
            e = e.replacingOccurrences(of: "{{+enum_protocols+}}", with: protocolConformances.enumerated().map {
                if $0.offset == 0 { return ": \($0.element)" }
                return ", \($0.element)"
            }.joined())
        } else { e = e.replacingOccurrences(of: "{{+enum_protocols+}}", with: "") }
    }
    
    //Find the largest Key for formatting reasons...
    var largestKey = 0
    cases.forEach { if $0.title.count > largestKey { largestKey = $0.title.count } }
    largestKey = largestKey + 1
    
    e = e.replacingOccurrences(of: "{{+enum_cases+}}", with: cases.map { generateCase($0, rawValueOffset: largestKey) }.joined(separator: "\n\t"))
    
    let additionalComponents = ENUM_ADDITIONAL_COMPONENTS.replacingOccurrences(of: "{{+enum_scope+}}", with: scope.rawValue)
    e = e.replacingOccurrences(of: "{{+enum_additional_components+}}", with: "\n\(additionalComponents)")
    
    if !computedProps.isEmpty {
        e = e.replacingOccurrences(of: "{{+enum_computed_properties+}}", with: computedProps.map {
            generateComputedProperty($0, cases: cases, scope: scope)
        }.joined(separator: "\n"))
    } else {
        e = e.replacingOccurrences(of: "{{+enum_computed_properties+}}", with: "")
    }
    e = e.replacingOccurrences(of: "{{+enum_functions+}}", with: "")
    //print(e)
    
    return e.data(using: .utf8)
}

func generateCase(_ enumCase:EnumCase, rawValueOffset:Int = 1) -> String {
    var c = ENUM_CASE
    c = c.replacingOccurrences(of: "{{+case_title+}}", with: enumCase.title)
    if let rv = enumCase.rawValue {
        c = c.replacingOccurrences(of: "{{+case_rawValue+}}", with: "\(String(repeating: " ", count: rawValueOffset - enumCase.title.count))= \(rv)")
        c = c.replacingOccurrences(of: "{{+case_associatedValues+}}", with: "")
    } else if let av = enumCase.associatedValue {
        c = c.replacingOccurrences(of: "{{+case_associatedValues+}}", with: "(\(av))")
        c = c.replacingOccurrences(of: "{{+case_rawValue+}}", with: "")
    } else {
        c = c.replacingOccurrences(of: "{{+case_rawValue+}}", with: "") //Set to empty
        c = c.replacingOccurrences(of: "{{+case_associatedValues+}}", with: "") //Set to empty
    }
    return c
}

func generateComputedProperty(_ compProp:ComputedProperty, cases:[EnumCase], scope:Scope, depthIndent:Int = 1) -> String {
    var cp = ENUM_COMPUTED_PROPERTY
    cp = cp.replacingOccurrences(of: "{{+enum_scope+}}", with: scope.rawValue)
    cp = cp.replacingOccurrences(of: "{{+cp_title+}}", with: compProp.title)
    
    var rawType = "\(compProp.type.self)"
    if rawType.contains("Optional<") { // TODO: Nested Optionals Not Supported...
        rawType = rawType.replacingOccurrences(of: "Optional<", with: "")
        rawType = rawType.replacingOccurrences(of: ">", with: "?")
    }
    cp = cp.replacingOccurrences(of: "{{+cp_type+}}", with: rawType)
    
    var defaultNeeded:Bool = false
    let entries:[String] = cases.compactMap {
        if let val = $0.computedProperties[compProp.caseKey] {
            var entry = COMPUTED_PROPERTY_CASE
            if $0.title == "p2p" {
                entry = entry.replacingOccurrences(of: "{{+case_title+}}", with: $0.title + ", .ipfs")
            } else {
                entry = entry.replacingOccurrences(of: "{{+case_title+}}", with: $0.title)
            }
            if rawType.lowercased().contains("string") {
                entry = entry.replacingOccurrences(of: "{{+case_value+}}", with: "\"\(val)\"")
            } else {
                entry = entry.replacingOccurrences(of: "{{+case_value+}}", with: "\(val)")
            }
            return entry
        }
        defaultNeeded = true
        return nil
    }
    if !entries.isEmpty {
        cp = cp.replacingOccurrences(of: "{{+cp_case+}}", with: "\(entries.joined(separator: "\n").replacingOccurrences(of: "\n", with: "\n\(String(repeating: "\t", count: depthIndent))"))")
    } else {
        cp = cp.replacingOccurrences(of: "{{+cp_case+}}", with: "")
    }
    
    cp = cp.replacingOccurrences(of: "{{+cp_default+}}", with: defaultNeeded ? "default: return \(compProp.defaultValue)" : "")
    
    cp = cp.replacingOccurrences(of: "\n", with: "\n\(String(repeating: "\t", count: depthIndent))")
    
    return "\n\(String(repeating: "\t", count: depthIndent))\(cp)"
}


// MARK: - Script to fetch CSV, Parse, Generate ENUM and update Codecs.swift...

/// Fetch CSV Data from repository
guard let str = fetchContents(url: CSVDocumentURL) else {
    exit(EXIT_FAILURE)
}
let entries = parseStringIntoCSV(str, headerRow: 0)

/// Itterate over the CSV data and extract out each Enum case
let enumCases:[EnumCase] = entries.compactMap {
    if let name = $0.columns.first(where: {$0.key == "name"})?.value, let rv = $0.columns.first(where: {$0.key == "code"})?.value {
        let ec = EnumCase(title: name.replacingOccurrences(of: "-", with: "_"), rawValue: rv)
        $0.columns.forEach { ec.computedProperties[$0.key] = $0.value }
        return ec
    }
    return nil
}.filter({ /// Remove Deprecated Codecs (ex: ipfs) ( Looks for the word 'deprecated' in the 'description' column )
    if let desc = $0.computedProperties["description"], let d = desc as? String { return !d.lowercased().contains("deprecated") }
    return true
})

guard !enumCases.isEmpty else {
    print("Codec table returned zero parseable results. Returning without updating.")
    exit(EXIT_FAILURE)
}

/// Generate the necessary computed properties to match the table
let compPropTag = ComputedProperty(title: "tag", type: String.self, defaultValue: "", caseKey: "tag")
let compPropDes = ComputedProperty(title: "description", type: Optional<String>.self, defaultValue: "nil", caseKey: "description")

/// Generate the final Enum
guard let data = generateEnum(scope: .PUBLIC, title: "Codecs", rawType: UInt64.self, protocolConformances: ["CaseIterable", "Equatable"], cases: enumCases, computedProps: [compPropTag, compPropDes]) else {
    print("Failed to generate Codecs enumeration. Returning without updating.")
    exit(EXIT_FAILURE)
}

/// Write Data to Codecs.swift...
guard let codecsURL = URL(string: "Sources/Multicodec/Codecs.swift", relativeTo: URL(fileURLWithPath: FileManager.default.currentDirectoryPath)) else {
    print("Failed to locate the local Codecs.swift file for update. Returning without updating.")
    exit(EXIT_FAILURE)
}

do {
    try data.write(to: codecsURL)
    print("Updated Codecs Successfully!")
    exit(EXIT_SUCCESS)
} catch {
    print("Error Updating Codecs.swift -> \(error.localizedDescription)")
    exit(EXIT_FAILURE)
}


